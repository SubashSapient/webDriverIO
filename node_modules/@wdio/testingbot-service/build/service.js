"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _request = _interopRequireDefault(require("request"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('@wdio/testingbot-service');
const jobDataProperties = ['name', 'tags', 'public', 'build', 'extra'];

class TestingBotService {
  constructor() {
    this.testCnt = 0;
    this.failures = 0;
  }

  beforeSession(config, capabilities) {
    this.config = config;
    this.capabilities = capabilities;
    this.config.user = config.user;
    this.config.key = config.key;
    this.tbUser = this.config.user;
    this.tbSecret = this.config.key;
    this.isServiceEnabled = this.tbUser && this.tbSecret;
  }

  beforeSuite(suite) {
    this.suiteTitle = suite.title;
  }

  beforeTest(test) {
    if (!this.isServiceEnabled) {
      return;
    }

    if (this.suiteTitle === 'Jasmine__TopLevel__Suite') {
      this.suiteTitle = test.fullName.slice(0, test.fullName.indexOf(test.title) - 1);
    }

    const context = test.parent === 'Jasmine__TopLevel__Suite' ? test.fullName : test.parent + ' - ' + test.title;
    global.browser.execute('tb:test-context=' + context);
  }

  afterSuite(suite) {
    if (Object.prototype.hasOwnProperty.call(suite, 'error')) {
      ++this.failures;
    }
  }

  afterTest(test) {
    if (!test.passed) {
      ++this.failures;
    }
  }

  beforeFeature(uri, feature) {
    if (!this.isServiceEnabled) {
      return;
    }

    this.suiteTitle = feature.document.feature.name;
    global.browser.execute('tb:test-context=Feature: ' + this.suiteTitle);
  }

  beforeScenario(uri, feature, scenario) {
    if (!this.isServiceEnabled) {
      return;
    }

    const scenarioName = scenario.name;
    global.browser.execute('tb:test-context=Scenario: ' + scenarioName);
  }

  afterScenario(uri, feature, pickle, result) {
    if (result.status === 'failed') {
      ++this.failures;
    }
  }

  after(result) {
    if (!this.isServiceEnabled) {
      return;
    }

    let failures = this.failures;

    if (global.browser.config.mochaOpts && global.browser.config.mochaOpts.bail && Boolean(result)) {
      failures = 1;
    }

    const status = 'status: ' + (failures > 0 ? 'failing' : 'passing');

    if (!global.browser.isMultiremote) {
      log.info(`Update job with sessionId ${global.browser.sessionId}, ${status}`);
      return this.updateJob(global.browser.sessionId, failures);
    }

    return Promise.all(Object.keys(this.capabilities).map(browserName => {
      log.info(`Update multiremote job for browser "${browserName}" and sessionId ${global.browser[browserName].sessionId}, ${status}`);
      return this.updateJob(global.browser[browserName].sessionId, failures, false, browserName);
    }));
  }

  onReload(oldSessionId, newSessionId) {
    if (!this.isServiceEnabled) {
      return;
    }

    const status = 'status: ' + (this.failures > 0 ? 'failing' : 'passing');

    if (!global.browser.isMultiremote) {
      log.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${status}`);
      return this.updateJob(oldSessionId, this.failures, true);
    }

    const browserName = global.browser.instances.filter(browserName => global.browser[browserName].sessionId === newSessionId)[0];
    log.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${status}`);
    return this.updateJob(oldSessionId, this.failures, true, browserName);
  }

  updateJob(sessionId, failures, calledOnReload = false, browserName) {
    return new Promise((resolve, reject) => _request.default.put(this.getRestUrl(sessionId), {
      json: true,
      auth: {
        user: this.tbUser,
        pass: this.tbSecret
      },
      body: this.getBody(failures, calledOnReload, browserName)
    }, (e, res, body) => {
      this.failures = 0;

      if (e) {
        return reject(e);
      }

      global.browser.jobData = body;
      return resolve(body);
    }));
  }

  getRestUrl(sessionId) {
    return `https://api.testingbot.com/v1/tests/${sessionId}`;
  }

  getBody(failures, calledOnReload = false, browserName) {
    let body = {
      test: {}
    };
    body.test['name'] = this.suiteTitle;

    if (calledOnReload || this.testCnt) {
      let testCnt = ++this.testCnt;

      if (global.browser.isMultiremote) {
        testCnt = Math.ceil(testCnt / global.browser.instances.length);
      }

      body.test['name'] += ` (${testCnt})`;
    }

    for (let prop of jobDataProperties) {
      if (!this.capabilities[prop]) {
        continue;
      }

      body.test[prop] = this.capabilities[prop];
    }

    if (browserName) {
      body.test['name'] = `${browserName}: ${body.test['name']}`;
    }

    body.test['success'] = failures === 0 ? '1' : '0';
    return body;
  }

}

exports.default = TestingBotService;